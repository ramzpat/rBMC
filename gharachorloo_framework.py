# Gharachorloo framework



from encodingFW import *


# Abstract model def 
Proc = 		DeclareSort('Proc') 			# Processor
Loc = 		DeclareSort('Loc')				# Location
Opr = 		DeclareSort('Opr')				# Operation
Val = 		IntSort()						# Value in the systems

MemOp = 	DeclareSort('MemOp')			# Memory operation 	
# AtomicOp =	DeclareSort('AtomicOp')			# Atomic operation 	
FenceOp =	DeclareSort('FenceOp')			# Fence operation 	

ReadOp = 	DeclareSort('ReadOp')			# Read access 	*A kind of memory operation(MemOp)
WriteOp = 	DeclareSort('WriteOp')			# Write access 	*A kind of memory operation(MemOp) 

SubOpr =	DeclareSort('SubOpr')			# Memory access on a specific Processor 	*generated by memory operation(MemOp)

# Functions 
# Wrapper functions
memOp =		Function('memOp', MemOp, Opr)			# MemOp is a subsort of Instr
# atomicOp =	Function('atomicOp', AtomicOp, Opr) 	# AtomicOp is a subsort of Instr
fenceOp =	Function('fenceOp', FenceOp, Opr)		# fenceOp is a subsort of Instr
read = 		Function('read', ReadOp, MemOp)			# ReadOp is a subsort of MemOp
write = 	Function('write', WriteOp, MemOp)		# WriteOp is a subsort of MemOp
subOpr = 	Function('subOpr', MemOp, Proc, SubOpr)	# A constructor for SubOpr

# Program define function
issue_proc =	Function('issue_proc', Opr, Proc)
mem_access = 	Function('mem_access', MemOp, Loc)
write_val =		Function('write_val', WriteOp, Val)
return_val = 	Function('return_val', ReadOp, Val)

initial_value = Function('initial_value', Loc, Val)
final_value = Function('final_value', Loc, Val)

# Predicates 
conflict = 		Function('conflict', MemOp, MemOp, BoolSort())		# Conflict 
po =			Function('po', Opr, Opr, BoolSort())				# Program order (Opr)
xo = 			Function('xo', SubOpr, SubOpr, BoolSort())			# Execution order 
co = 			Function('co', MemOp, MemOp, BoolSort())			# Conflict order 
ico = 			Function('ico', MemOp, MemOp, BoolSort())			# Inter conflict order 

# Value casting
Opr.cast = (lambda val:
		val if (val.sort() == Opr)
		# else atomicOp(val) if ( val.sort() == AtomicOp )
		else fenceOp(val) if ( val.sort() == FenceOp )
		else memOp(MemOp.cast(val)) if ( val.sort() == MemOp or val.sort() ==  ReadOp or val.sort() == WriteOp )
		else fenceOp(FenceOp.cast(val))
	)
MemOp.cast = (lambda val:
		val if (val.sort() == MemOp)
		else read(val) if (val.sort() == ReadOp)
		else write(val) 
	)

subOpr.domain = (lambda i: MemOp if i == 0 else Proc)

issue_proc.domain = (lambda i: Opr)
mem_access.domain = (lambda i: MemOp)
write_val.domain = (lambda i: WriteOp)
return_val.domain = (lambda i: ReadOp)

conflict.domain = (lambda i: MemOp)
po.domain = (lambda i: Opr)
xo.domain = (lambda i: SubOpr)
co.domain = (lambda i: MemOp)
ico.domain = (lambda i: MemOp)

class encoder(encodingFW):

	def supportedModels(self):
		return ['SC', 'TSO', 'PSO']

	def new_write(self, var, exp, pid):
		name = 'write_' + str(self.info['EventCnt'])
		self.info['EventCnt'] = self.info['EventCnt'] + 1
		write = Const(name, WriteOp)

		pid = Const('P'+str(pid), Proc)
		self.info['CS'] += [
			write_val(write) == exp,
			mem_access(write) == var, 
			issue_proc(write) == pid
		]

		return write
	def new_read(self, var, exp, pid):
		name = 'read_' + str(self.info['EventCnt'])
		self.info['EventCnt'] = self.info['EventCnt'] + 1
		read = Const(name, ReadOp)

		pid = Const('P'+str(pid), Proc)
		print var , return_val(read)
		self.info['CS'] += [
			var == return_val(read),
			mem_access(read) == exp, 
			issue_proc(read) == pid
		]		
		return read
	def new_loc(self, addr):
		return Const(str(addr), Loc)

	def new_branch(self, pid):
		# raise NotImplementedError()
		return None

	def encodeElement(self, e):

		assert(isinstance(e, Exp) or isinstance(e, Register) or type(e) == int or type(e) == bool)
		
		if type(e) == int or type(e) == bool:
			return e
		elif isinstance(e, Register):
			return Int(str(e))
		# elif isinstance(e, Register):
		# 	if not(str(e) in info['Reg'].keys()):
		# 		info['Reg'][str(e)] = herd.Reg(info['RegCnt'])
		# 		info['RegCnt'] += 1
		# 	return (info['Reg'][str(e)], info)
		elif isinstance(e, Location):
			if not(e.address in self.info['Loc'].keys()):
				addrLoc = Int(str(e.address))
				self.info['Loc'][e.address] = self.new_loc(addrLoc) # InitLoc(addrLoc)
			return self.info['Loc'][e.address]
		elif isinstance(e, ifExp):
			# val := (cond)?1:0
			# r1 << val 
			return None
		elif isinstance(e, undefinedExp):
			return FreshInt()
		elif isinstance(e, Exp):
			return self.encodeExp(e)

		return None

	def encodeOpr(self, i):
		assert(isinstance(i, Operation))
		encodeOp = None 
		pid = self.info['Pid']

		if isinstance(i, WriteAssn) and isinstance(i.var, Location):		
			exp = self.encodeElement(i.exp)
			var = self.encodeElement(i.var)
			encodeOp = self.new_write(var, exp, pid)
			
		elif isinstance(i, ReadAssn) and isinstance(i.exp, Location):
			var = self.encodeElement(i.var)
			exp = self.encodeElement(i.exp)
			encodeOp = self.new_read(var, exp, pid)
		elif isinstance(i, Assignment):
			var = self.encodeElement(i.var)
			if not isinstance(i.exp, ifExp):
				exp = self.encodeElement(i.exp)
				self.info['CS'] += [var == exp]
			else:
				# val := (cond)?1:0
				cond = self.encodeElement(i.exp.cond)
				tExp = self.encodeElement(i.exp.t_exp)
				fExp = self.encodeElement(i.exp.f_exp)
				self.info['CS'] += [ Implies(cond, var == tExp), 
								Implies(Not(cond), var == fExp) ]
		elif isinstance(i, fenceStm):
			encodeOp = self.specialEncode(i)
			# print '&&&', encodeOp, i.__class__
		elif isinstance(i, branchOp):
			encodeOp = self.new_branch(pid)
		elif isinstance(i, RmwStm):
			assert(False)

		return encodeOp

	def encodeSpecific(self):
		# print self.info['CS']

		# create sub-opr
		# xo on sub-opr 
		


		return And(self.info['CS'])





		
