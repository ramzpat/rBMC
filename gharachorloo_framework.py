# Gharachorloo framework



from encodingFW import *


# Abstract model def 
Proc = 		DeclareSort('Proc') 			# Processor
Loc = 		DeclareSort('Loc')				# Location
Opr = 		DeclareSort('Opr')				# Operation
Val = 		IntSort()						# Value in the systems

MemOp = 	DeclareSort('MemOp')			# Memory operation 	
# AtomicOp =	DeclareSort('AtomicOp')			# Atomic operation 	
FenceOp =	DeclareSort('FenceOp')			# Fence operation 	

ReadOp = 	DeclareSort('ReadOp')			# Read access 	*A kind of memory operation(MemOp)
WriteOp = 	DeclareSort('WriteOp')			# Write access 	*A kind of memory operation(MemOp) 

SubOpr =	DeclareSort('SubOpr')			# Memory access on a specific Processor 	*generated by memory operation(MemOp)

# Functions 
# Wrapper functions
memOp =		Function('memOp', MemOp, Opr)			# MemOp is a subsort of Instr
# atomicOp =	Function('atomicOp', AtomicOp, Opr) 	# AtomicOp is a subsort of Instr
fenceOp =	Function('fenceOp', FenceOp, Opr)		# fenceOp is a subsort of Instr
read = 		Function('read', ReadOp, MemOp)			# ReadOp is a subsort of MemOp
write = 	Function('write', WriteOp, MemOp)		# WriteOp is a subsort of MemOp
subOpr = 	Function('subOpr', MemOp, Proc, SubOpr)	# A constructor for SubOpr

# Program define function
issue_proc =	Function('issue_proc', Opr, Proc)
mem_access = 	Function('mem_access', MemOp, Loc)
write_val =		Function('write_val', WriteOp, Val)
return_val = 	Function('return_val', ReadOp, Val)

initial_value = Function('initial_value', Loc, Val)
final_value = Function('final_value', Loc, Val)

# Predicates 
conflict = 		Function('conflict', MemOp, MemOp, BoolSort())		# Conflict 
po =			Function('po', Opr, Opr, BoolSort())				# Program order (Opr)
xo = 			Function('xo', SubOpr, SubOpr, BoolSort())			# Execution order 
co = 			Function('co', MemOp, MemOp, BoolSort())			# Conflict order 
ico = 			Function('ico', MemOp, MemOp, BoolSort())			# Inter conflict order 

# Value casting
Opr.cast = (lambda val:
		val if (val.sort() == Opr)
		# else atomicOp(val) if ( val.sort() == AtomicOp )
		else fenceOp(val) if ( val.sort() == FenceOp )
		else memOp(MemOp.cast(val)) if ( val.sort() == MemOp or val.sort() ==  ReadOp or val.sort() == WriteOp )
		else fenceOp(FenceOp.cast(val))
	)
MemOp.cast = (lambda val:
		val if (val.sort() == MemOp)
		else read(val) if (val.sort() == ReadOp)
		else write(val) 
	)

subOpr.domain = (lambda i: MemOp if i == 0 else Proc)

issue_proc.domain = (lambda i: Opr)
mem_access.domain = (lambda i: MemOp)
write_val.domain = (lambda i: WriteOp)
return_val.domain = (lambda i: ReadOp)

conflict.domain = (lambda i: MemOp)
po.domain = (lambda i: Opr)
xo.domain = (lambda i: SubOpr)
co.domain = (lambda i: MemOp)
ico.domain = (lambda i: MemOp)

class encoder(encodingFW):

	def supportedModels(self):
		return ['SC', 'TSO', 'PSO']

	def new_write(self, var, exp, pid):
		name = 'write_' + str(self.info['EventCnt'])
		write = Const(name, WriteOp)
		write.eid = self.info['EventCnt']
		self.info['EventCnt'] = self.info['EventCnt'] + 1


		pid = Const('P'+str(pid), Proc)
		self.info['CS'] += [
			write_val(write) == exp,
			mem_access(write) == var, 
			issue_proc(write) == pid
		]

		return write
	def new_read(self, var, exp, pid):
		name = 'read_' + str(self.info['EventCnt'])
		read = Const(name, ReadOp)
		read.eid = self.info['EventCnt']
		self.info['EventCnt'] = self.info['EventCnt'] + 1
		

		pid = Const('P'+str(pid), Proc)
		print var , return_val(read)
		self.info['CS'] += [
			var == return_val(read),
			mem_access(read) == exp, 
			issue_proc(read) == pid
		]		
		return read
	def new_loc(self, addr):
		return Const(str(addr), Loc)

	def new_branch(self, pid):
		# raise NotImplementedError()
		return None

	def encodeElement(self, e):

		assert(isinstance(e, Exp) or isinstance(e, Register) or type(e) == int or type(e) == bool)
		
		if type(e) == int or type(e) == bool:
			return e
		elif isinstance(e, Register):
			return Int(str(e))
		# elif isinstance(e, Register):
		# 	if not(str(e) in info['Reg'].keys()):
		# 		info['Reg'][str(e)] = herd.Reg(info['RegCnt'])
		# 		info['RegCnt'] += 1
		# 	return (info['Reg'][str(e)], info)
		elif isinstance(e, Location):
			if not(e.address in self.info['Loc'].keys()):
				addrLoc = Int(str(e.address))
				self.info['Loc'][e.address] = self.new_loc(addrLoc) # InitLoc(addrLoc)
			return self.info['Loc'][e.address]
		elif isinstance(e, ifExp):
			# val := (cond)?1:0
			# r1 << val 
			return None
		elif isinstance(e, undefinedExp):
			return FreshInt()
		elif isinstance(e, Exp):
			return self.encodeExp(e)

		return None

	def encodeOpr(self, i):
		assert(isinstance(i, Operation))
		encodeOp = None 
		pid = self.info['Pid']

		if isinstance(i, WriteAssn) and isinstance(i.var, Location):		
			exp = self.encodeElement(i.exp)
			var = self.encodeElement(i.var)
			encodeOp = self.new_write(var, exp, pid)
			
		elif isinstance(i, ReadAssn) and isinstance(i.exp, Location):
			var = self.encodeElement(i.var)
			exp = self.encodeElement(i.exp)
			encodeOp = self.new_read(var, exp, pid)
		elif isinstance(i, Assignment):
			var = self.encodeElement(i.var)
			if not isinstance(i.exp, ifExp):
				exp = self.encodeElement(i.exp)
				self.info['CS'] += [var == exp]
			else:
				# val := (cond)?1:0
				cond = self.encodeElement(i.exp.cond)
				tExp = self.encodeElement(i.exp.t_exp)
				fExp = self.encodeElement(i.exp.f_exp)
				self.info['CS'] += [ Implies(cond, var == tExp), 
								Implies(Not(cond), var == fExp) ]
		elif isinstance(i, fenceStm):
			encodeOp = self.specialEncode(i)
			# print '&&&', encodeOp, i.__class__
		elif isinstance(i, branchOp):
			encodeOp = self.new_branch(pid)
		elif isinstance(i, RmwStm):
			assert(False)

		return encodeOp

	def encodeSpecific(self):
		
		# realize po
		for x in self.info['Ev']:
			for y in self.info['Ev']:
				self.info['CS'] += [ po(x,y) if (x.eid,y.eid) in self.info['poS'] else Not(po(x,y)) ]

		# initial_location
		for L in self.info['Loc'].values():
			self.info['CS'] += [initial_value(L) == 0]

		# underlying axioms
		# axioms = self.based_axioms()


		return And(self.info['CS'])

	def based_axioms(self):

		# Conflict 
		def conflict_def(w1, w2):
			(wA, locA, pA) = w1
			(wB, locB, pB) = w2
			if wA.sort() == WriteOp or wB.sort() == WriteOp:
				return (hw.conflict(wA, wB) == eq(locA,locB))
			else: 
				return (Not(hw.conflict(wA, wB)))

		conflict_manual_def = []
		write = info['MemOp']['write']
		read = info['MemOp']['read']
		rmwList = info['MemOp']['rmw']
		memOp = write + read
		# for (a, loc, p) in rmwList:
		# 	memOp += [(hw.atomic_write(a),loc,p), (hw.atomic_read(a), loc, p)]
		conflict_manual_def += [ conflict_def(w1, w2) for (w1, w2) in itertools.permutations(memOp, 2)]
		
		# -co-> definition
		def co_def(w1, w2):
			(wA, locA, pA) = w1
			(wB, locB, pB) = w2
			i = Const('i', Proc)
			if (wA.sort() == WriteOp or wB.sort() == WriteOp) and (locA == locB):
				return (hw.co(wA, wB) == Exists([i],xo(subOpr(wA,i), subOpr(wB,i))))
			else:
				return Not(hw.co(wA, wB))

		# -co'-> definition
		def ico_def(w1, w2):
			(wA, locA, pA) = w1
			(wB, locB, pB) = w2
			i = Const('i', Proc)
			if (wA.sort() == WriteOp or wB.sort() == WriteOp) and (locA == locB) and not eq(pA,pB):
				return (hw.ico(wA, wB) == Exists([i],xo(subOpr(wA,i), subOpr(wB,i))))
			else:
				return Not(hw.ico(wA, wB))

		conflict_manual_def += [ co_def(w1, w2) for (w1, w2) in itertools.permutations(memOp, 2)]
		conflict_manual_def += [ ico_def(w1, w2) for (w1, w2) in itertools.permutations(memOp, 2)]

		# print conflict_manual_def


		rw1, rw2 = Consts('rw1 rw2', MemOp)
		# rmw = Const('rmw', AtomicOp)
		# rmw1, rmw2 = Consts('rmw1 rmw2', AtomicOp)
		w = Const('w', WriteOp)
		r1, r2 = Consts('r1 r2', ReadOp)
		i, j = Consts('i j', Proc)
		
		def __atomicExce(subAtomR, subAtomW, subW):
		# return And( xo(subAtomR, subW), xo(subAtomW, subW) )
			return Xor( 
					And( xo(subAtomR, subW), xo(subAtomW, subW) ),
					And( xo(subW, subAtomR), xo(subW, subAtomW) ))

		# Cond 3 : read-modify-write behaviors
		axioms_atomic = []
		for ((rmw_r, loc, pi), (rmw_w, loc, pi)) in rmwList:
			axioms_atomic += [
				ForAll(w, 
						Implies(
							And(conflict(rmw_w, w)),
							__atomicExce(
								subOpr(rmw_r, pi), 
								subOpr(rmw_w, pi), 
								subOpr(w, pi)
								)
							)
					)
			]

		# Partial order axioms 
		def DeclareList(sort):
		    List = Datatype('List_of_%s' % sort.name())
		    List.declare('cons', ('car', sort), ('cdr', List))
		    List.declare('nil')
		    return List.create()

		def partial_order_axioms(func):	
			assert(func.domain(0) == func.domain(1))
			x, y, z  = Consts('x y z', func.domain(0))
			irreflexive_axiom = ForAll([x,y], Implies(func(x,y), x != y) )
			# asymetric_axiom = ForAll([x,y], Implies( func(x,y), Not( func(y,x) )))
			transitivity_axiom = ForAll([x,y,z], Implies( And(func(x,y), func(y,z)), func(x,z) ))
			return [
				irreflexive_axiom, 
				# asymetric_axiom, 
				transitivity_axiom
				]

		# asymetric for xo
		x, y = Consts('x y', SubOpr)
		a, b = Consts('a b', MemOp)
		i, j = Consts('i j', Proc)
		addition_order = [
			ForAll([x,y], Implies( xo(x,y), Not( xo(y,x) ))),
			ForAll([a,b], Implies(issue_proc(a) != issue_proc(b), Not(po(a,b)) )),
			ForAll([a,b], Implies(And(issue_proc(a) == issue_proc(b), po(a,b)), Not(po(b,a) )))
		]
		
		return (
			conflict_manual_def
			# + conflict_def_axiom
			# + inconflict_def_axiom 
			+ partial_order_axioms(po) 
			+ partial_order_axioms(xo)
			+ addition_order
			+ axioms_atomic 
			)
		






		
