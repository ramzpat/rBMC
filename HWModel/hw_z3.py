# HW_Z3.py
from z3 import *

# Abstract model def 
Proc = 		DeclareSort('Proc') 			# Processor
Loc = 		DeclareSort('Loc')				# Location
Opr = 	DeclareSort('Opr')					# Operation
Val = 		IntSort()						# Value in the systems

MemOp = 	DeclareSort('MemOp')			# Memory operation 	
# AtomicOp =	DeclareSort('AtomicOp')			# Atomic operation 	
FenceOp =	DeclareSort('FenceOp')			# Fence operation 	

ReadOp = 	DeclareSort('ReadOp')			# Read access 	*A kind of memory operation(MemOp)
WriteOp = 	DeclareSort('WriteOp')			# Write access 	*A kind of memory operation(MemOp) 

SubOpr =	DeclareSort('SubOpr')			# Memory access on a specific Processor 	*generated by memory operation(MemOp)

# Functions 
# Wrapper functions
memOp =		Function('memOp', MemOp, Opr)			# MemOp is a subsort of Instr
# atomicOp =	Function('atomicOp', AtomicOp, Opr) 	# AtomicOp is a subsort of Instr
fenceOp =	Function('fenceOp', FenceOp, Opr)		# fenceOp is a subsort of Instr

read = 		Function('read', ReadOp, MemOp)			# ReadOp is a subsort of MemOp
write = 	Function('write', WriteOp, MemOp)		# WriteOp is a subsort of MemOp

subOpr = 	Function('subOpr', MemOp, Proc, SubOpr)	# A constructor for SubOpr

# atomic_read = Function('atomic_read', AtomicOp, ReadOp)		# A ReadOp generated by AtomicOp
# atomic_write = Function('atomic_write', AtomicOp, WriteOp)	# A WriteOp generated by AtomicOp

# Program define function
issue_proc =	Function('issue_proc', Opr, Proc)
mem_access = 	Function('mem_access', MemOp, Loc)
write_val =		Function('write_val', WriteOp, Val)
return_val = 	Function('return_val', ReadOp, Val)

initial_value = Function('initial_value', Loc, Val)
final_value = Function('final_value', Loc, Val)

# Predicates 
conflict = 		Function('conflict', MemOp, MemOp, BoolSort())		# Conflict 
po =			Function('po', Opr, Opr, BoolSort())				# Program order (Opr)
xo = 			Function('xo', SubOpr, SubOpr, BoolSort())			# Execution order 
co = 			Function('co', MemOp, MemOp, BoolSort())			# Conflict order 
ico = 			Function('ico', MemOp, MemOp, BoolSort())			# Inter conflict order 


# Value casting
Opr.cast = (lambda val:
		val if (val.sort() == Opr)
		# else atomicOp(val) if ( val.sort() == AtomicOp )
		else fenceOp(val) if ( val.sort() == FenceOp )
		else memOp(MemOp.cast(val)) if ( val.sort() == MemOp or val.sort() ==  ReadOp or val.sort() == WriteOp )
		else fenceOp(FenceOp.cast(val))
	)
MemOp.cast = (lambda val:
		val if (val.sort() == MemOp)
		else read(val) if (val.sort() == ReadOp)
		else write(val) 
	)

subOpr.domain = (lambda i: MemOp if i == 0 else Proc)

issue_proc.domain = (lambda i: Opr)
mem_access.domain = (lambda i: MemOp)
write_val.domain = (lambda i: WriteOp)
return_val.domain = (lambda i: ReadOp)

conflict.domain = (lambda i: MemOp)
po.domain = (lambda i: Opr)
xo.domain = (lambda i: SubOpr)
co.domain = (lambda i: MemOp)
ico.domain = (lambda i: MemOp)


